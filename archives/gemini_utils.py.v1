import requests
import json
import os

# Using the API key provided by the user for this specific request
# In a production environment, use environment variables for security
GEMINI_API_KEY = "AIzaSyAnp0lHEZnajMbDavNPrrTUhSGareRwFp0" # Replace with your actual API key or use environment variable

# Updated API URL based on the user's working curl command
# Using gemini-2.0-flash model and generateContent endpoint
GEMINI_API_URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={GEMINI_API_KEY}"

def fetch_verse_from_gemini(chapter, verse):
    """
    Fetches a specific Bhagavad Gita verse and its meaning in Telugu
    from the Gemini API using the generateContent endpoint.

    Args:
        chapter (int): The chapter number.
        verse (int): The verse number.

    Returns:
        tuple: A tuple containing (telugu_verse, telugu_meaning) if successful,
               otherwise (None, None).
    """
    if not GEMINI_API_KEY:
        print("Error: GEMINI_API_KEY is not set.")
        return None, None

    # Prompt tailored to get the verse and meaning in Telugu
    prompt = f"Provide Bhagavad Gita Chapter {chapter}, Verse {verse} in Telugu script and its meaning in Telugu script. Format the output clearly with the verse first, followed by the meaning. Label them explicitly as 'Verse:' and 'Meaning:'. Ensure the response is only the verse and meaning, without conversational text."

    headers = {
        'Content-Type': 'application/json'
    }

    # Request body structure matching the working curl command
    data = {
        "contents": [
            {
                "parts": [
                    {"text": prompt}
                ]
            }
        ]
    }

    try:
        print(f"Calling Gemini API for Chapter {chapter}, Verse {verse}...")
        # Use POST method as shown in the working curl command
        response = requests.post(GEMINI_API_URL, headers=headers, data=json.dumps(data))
        response.raise_for_status() # Raise an exception for bad status codes (like 4xx or 5xx)

        response_data = response.json()

        # Parse the response to extract the verse and meaning
        # The structure is expected to be response_data['candidates'][0]['content']['parts'][0]['text']
        telugu_verse = None
        telugu_meaning = None

        if 'candidates' in response_data and response_data['candidates']:
            candidate = response_data['candidates'][0]
            if 'content' in candidate and 'parts' in candidate['content']:
                text_content = candidate['content']['parts'][0]['text']

                # Basic parsing: look for "Verse:" and "Meaning:" labels
                # This parsing is still somewhat fragile and depends on the API's consistent formatting
                verse_label = "Verse:"
                meaning_label = "Meaning:"

                verse_start = text_content.find(verse_label)
                meaning_start = text_content.find(meaning_label)

                if verse_start != -1 and meaning_start != -1 and meaning_start > verse_start:
                    # Extract text between labels
                    telugu_verse = text_content[verse_start + len(verse_label):meaning_start].strip()
                    telugu_meaning = text_content[meaning_start + len(meaning_label):].strip()
                else:
                    # Fallback if labels are not found or order is wrong - try to return the whole text
                    print("Warning: 'Verse:' or 'Meaning:' labels not found or in unexpected order in Gemini response. Attempting alternative parsing.")
                    # A more robust fallback might involve splitting lines or looking for patterns
                    # For now, let's try a simpler split if labels aren't found
                    lines = text_content.strip().split('\n')
                    if len(lines) >= 2:
                        telugu_verse = lines[0].strip()
                        telugu_meaning = "\n".join(lines[1:]).strip()
                    else:
                         print("Warning: Could not parse verse/meaning from response text.")
                         telugu_verse = text_content.strip()
                         telugu_meaning = "Meaning could not be parsed."


        if telugu_verse and telugu_meaning and telugu_verse != "Meaning could not be parsed." and telugu_meaning != "Meaning could not be parsed.":
            print(f"Successfully fetched verse and meaning from Gemini.")
            return telugu_verse, telugu_meaning
        else:
            print("Error: Could not extract verse or meaning from Gemini response after parsing attempts.")
            print("Gemini Response Text:", text_content if 'text_content' in locals() else "N/A")
            print("Full Gemini Response Data:", response_data)
            return None, None

    except requests.exceptions.RequestException as e:
        print(f"Error calling Gemini API: {e}")
        return None, None
    except Exception as e:
        print(f"An unexpected error occurred during Gemini API call: {e}")
        print("Gemini Response Data (if available):", response_data if 'response_data' in locals() else "N/A")
        return None, None

if __name__ == '__main__':
    # Example usage (for testing the module directly)
    # Note: This will make an actual API call
    print("Testing gemini_utils.py...")
    verse_text, meaning_text = fetch_verse_from_gemini(chapter=2, verse=47)
    if verse_text and meaning_text:
        print("\n--- Fetched Verse ---")
        print(verse_text)
        print("\n--- Fetched Meaning ---")
        print(meaning_text)
    else:
        print("\nFailed to fetch verse from Gemini.")


