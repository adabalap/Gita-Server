from flask import Flask, request, jsonify
from flask_cors import CORS # Import CORS
import database
import gemini_utils

# Corrected Flask initialization: use __name__ instead of __init__
app = Flask(__name__)
# Enable CORS for all origins on all routes.
# In a production environment, you might want to restrict origins for security.
CORS(app)

# Initialize the database when the app starts.
# This will create the table and add missing columns if necessary.
database.init_db()

@app.route('/')
def index():
    """Basic route to confirm the API is running."""
    return "Bhagavath Geetha Telugu API is running!"

@app.route('/verse', methods=['GET'])
def get_bhagavath_geetha_verse():
    """
    API endpoint to retrieve a Bhagavad Gita verse and its meaning in Telugu.
    Expects 'chapter' and 'verse' as query parameters.
    """
    chapter = request.args.get('chapter', type=int)
    verse = request.args.get('verse', type=int)

    # Validate input
    if chapter is None or verse is None:
        print("Validation Error: Missing chapter or verse parameter.")
        return jsonify({"error": "దయచేసి 'chapter' మరియు 'verse' పారామితులను అందించండి."}), 400 # Please provide 'chapter' and 'verse' parameters.
    if chapter <= 0 or verse <= 0:
         print(f"Validation Error: Invalid chapter ({chapter}) or verse ({verse}) number.")
         return jsonify({"error": "అధ్యాయం మరియు శ్లోకం సంఖ్యలు ధనాత్మకంగా ఉండాలి."}), 400 # Chapter and verse numbers must be positive.

    print(f"Received request for Chapter {chapter}, Verse {verse}")

    # 1. Try to get the verse from the database
    verse_data = database.get_verse_from_db(chapter, verse)

    if verse_data:
        print(f"Found Chapter {chapter}, Verse {verse} in database.")
        # If found, return it. Use .get() for robustness in case columns are missing or NULL.
        return jsonify({
            "chapter": verse_data.get('chapter'),
            "verse": verse_data.get('verse'),
            "telugu_verse": verse_data.get('telugu_verse'),
            "telugu_meaning": verse_data.get('telugu_meaning'),
            # Use .get() with a default of None if the column/key doesn't exist on this row
            "polished_telugu_verse": verse_data.get('polished_telugu_verse', None),
            "polished_telugu_meaning": verse_data.get('polished_telugu_meaning', None),
            "telugu_description": verse_data.get('telugu_description', None),
            "source": "Database" # Indicate source
        })
    else:
        print(f"Chapter {chapter}, Verse {verse} not found in database. Attempting to fetch from Gemini...")
        # 2. If not found, fetch from Gemini API
        telugu_verse, telugu_meaning = gemini_utils.fetch_verse_from_gemini(chapter, verse)

        if telugu_verse and telugu_meaning:
            print(f"Successfully fetched Chapter {chapter}, Verse {verse} from Gemini.")
            # 3. Insert the fetched verse into the database for future use
            # Note: Polished text and description will be added later by enhance_db.py
            inserted = database.insert_verse_into_db(chapter, verse, telugu_verse, telugu_meaning)

            # Return the fetched data (without polished/description initially)
            return jsonify({
                "chapter": chapter,
                "verse": verse,
                "telugu_verse": telugu_verse,
                "telugu_meaning": telugu_meaning,
                "polished_telugu_verse": None, # Not available yet
                "polished_telugu_meaning": None, # Not available yet
                "telugu_description": None, # Not available yet
                "source": "Gemini API (Original Fetch)" # Indicate source
            })
        else:
            print(f"Failed to fetch Chapter {chapter}, Verse {verse} from Gemini.")
            # If fetching from Gemini fails
            return jsonify({
                "error": f"అధ్యాయం {chapter}, శ్లోకం {verse} డేటాబేస్ లేదా బాహ్య మూలం నుండి పొందలేకపోయింది." # Could not retrieve Chapter {chapter}, Verse {verse} from database or external source.
            }), 500 # Internal Server Error or appropriate error code

if __name__ == '__main__':
    # Use host='0.0.0.0' to make the server publicly accessible (be cautious in production)
    # debug=True is useful for development, but should be False in production
    app.run(debug=True, host='0.0.0.0')

